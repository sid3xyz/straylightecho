'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
require("core-js/modules/es.symbol.js");
require("core-js/modules/es.symbol.description.js");
require("core-js/modules/es.symbol.iterator.js");
require("core-js/modules/es.symbol.to-primitive.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.date.to-primitive.js");
require("core-js/modules/es.number.constructor.js");
require("core-js/modules/es.object.get-prototype-of.js");
require("core-js/modules/es.reflect.construct.js");
require("core-js/modules/es.string.iterator.js");
require("core-js/modules/web.dom-collections.iterator.js");
require("core-js/modules/es.array.concat.js");
require("core-js/modules/es.array.find.js");
require("core-js/modules/es.array.reduce.js");
require("core-js/modules/es.array.slice.js");
require("core-js/modules/es.function.bind.js");
require("core-js/modules/es.object.create.js");
require("core-js/modules/es.object.define-property.js");
require("core-js/modules/es.object.set-prototype-of.js");
require("core-js/modules/es.object.to-string.js");
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var _ = {
  reduce: require('lodash/reduce'),
  find: require('lodash/find'),
  uniq: require('lodash/uniq')
};
var EventEmitter = require('eventemitter3');
var irc_numerics = require('./numerics');
var IrcCommand = require('./command');
module.exports = /*#__PURE__*/function (_EventEmitter) {
  function IrcCommandHandler(client) {
    var _this;
    _classCallCheck(this, IrcCommandHandler);
    _this = _callSuper(this, IrcCommandHandler);

    // Adds an 'all' event to .emit()
    _this.addAllEventName();
    _this.client = client;
    _this.connection = client.connection;
    _this.network = client.network;
    _this.handlers = [];
    _this.request_extra_caps = [];
    _this.resetCache();
    require('./handlers/registration')(_this);
    require('./handlers/channel')(_this);
    require('./handlers/user')(_this);
    require('./handlers/messaging')(_this);
    require('./handlers/misc')(_this);
    require('./handlers/generics')(_this);
    return _this;
  }
  _inherits(IrcCommandHandler, _EventEmitter);
  return _createClass(IrcCommandHandler, [{
    key: "dispatch",
    value: function dispatch(message) {
      var irc_command = new IrcCommand(message.command.toUpperCase(), message);

      // Batched commands will be collected and executed as a transaction
      var batch_id = irc_command.getTag('batch');
      if (batch_id) {
        var cache_key = 'batch.' + batch_id;
        if (this.hasCache(cache_key)) {
          var cache = this.cache(cache_key);
          cache.commands.push(irc_command);
        } else {
          // If we don't have this batch ID in cache, it either means that the
          // server hasn't sent the starting batch command or that the server
          // has already sent the end batch command.
        }
      } else {
        this.executeCommand(irc_command);
      }
    }
  }, {
    key: "executeCommand",
    value: function executeCommand(irc_command) {
      var command_name = irc_command.command;

      // Check if we have a numeric->command name- mapping for this command
      if (irc_numerics[irc_command.command.toUpperCase()]) {
        command_name = irc_numerics[irc_command.command.toUpperCase()];
      }
      if (this.handlers[command_name]) {
        this.handlers[command_name](irc_command, this);
      } else {
        this.emitUnknownCommand(irc_command);
      }
    }
  }, {
    key: "requestExtraCaps",
    value: function requestExtraCaps(cap) {
      this.request_extra_caps = _.uniq(this.request_extra_caps.concat(cap));
    }
  }, {
    key: "addHandler",
    value: function addHandler(command, handler) {
      if (typeof handler !== 'function') {
        return false;
      }
      this.handlers[command] = handler;
    }
  }, {
    key: "emitUnknownCommand",
    value: function emitUnknownCommand(command) {
      this.emit('unknown command', command);
    }

    // Adds an 'all' event to .emit()
  }, {
    key: "addAllEventName",
    value: function addAllEventName() {
      var original_emit = this.emit;
      this.emit = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        original_emit.apply(this, ['all'].concat(args));
        original_emit.apply(this, args);
      };
    }

    /**
    * Convert a mode string such as '+k pass', or '-i' to a readable
    * format.
    * [ { mode: '+k', param: 'pass' } ]
    * [ { mode: '-i', param: null } ]
    */
  }, {
    key: "parseModeList",
    value: function parseModeList(mode_string, mode_params) {
      var chanmodes = this.network.options.CHANMODES || [];
      var prefixes = this.network.options.PREFIX || [];
      var always_param = (chanmodes[0] || '').concat(chanmodes[1] || '');
      var modes = [];
      var i;
      var j;
      var add;
      if (!mode_string) {
        return modes;
      }
      prefixes = _.reduce(prefixes, function (list, prefix) {
        list.push(prefix.mode);
        return list;
      }, []);
      always_param = always_param.split('').concat(prefixes);
      var hasParam = function hasParam(mode, isAdd) {
        var matchMode = function matchMode(m) {
          return m === mode;
        };
        if (_.find(always_param, matchMode)) {
          return true;
        }
        if (isAdd && _.find((chanmodes[2] || '').split(''), matchMode)) {
          return true;
        }
        return false;
      };
      j = 0;
      for (i = 0; i < mode_string.length; i++) {
        switch (mode_string[i]) {
          case '+':
            add = true;
            break;
          case '-':
            add = false;
            break;
          default:
            if (hasParam(mode_string[i], add)) {
              modes.push({
                mode: (add ? '+' : '-') + mode_string[i],
                param: mode_params[j]
              });
              j++;
            } else {
              modes.push({
                mode: (add ? '+' : '-') + mode_string[i],
                param: null
              });
            }
        }
      }
      return modes;
    }

    /**
     * Cache object for commands buffering data before emitting them
     * eg.
     * var cache = this.cache('userlist');
     * cache.nicks = [];
     * cache.destroy();
     */
  }, {
    key: "cache",
    value: function cache(id) {
      var cache = this._caches[id];
      if (!cache) {
        var destroyCacheFn = function destroyCacheFn(cacheToDestroy, idInCache) {
          return function () {
            delete cacheToDestroy[idInCache];
          };
        };

        // We don't want the destoryCache to be iterable
        cache = Object.defineProperty({}, 'destroy', {
          enumerable: false,
          configurable: false,
          value: destroyCacheFn(this._caches, id)
        });
        this._caches[id] = cache;
      }
      return cache;
    }
  }, {
    key: "hasCache",
    value: function hasCache(id) {
      return this._caches && Object.prototype.hasOwnProperty.call(this._caches, id);
    }
  }, {
    key: "resetCache",
    value: function resetCache() {
      this._caches = Object.create(null);
    }
  }]);
}(EventEmitter);